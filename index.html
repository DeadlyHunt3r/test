<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Uno mit Drag & Drop und Bildkarten</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #2d2d2d;
      font-family: Arial, sans-serif;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #game-container {
      border: 2px solid #fff;
      background: #1d1d1d;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <script>
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    const game = new Phaser.Game(config);

    let players = [];
    let currentPlayer = 0;
    let deck = [];
    let discardPile = [];
    let cardSprites = [];
    let drawButton;
    let scrollOffset = 0;

    const colors = ['Rot', 'Gelb', 'Gr√ºn', 'Blau'];
    const numbers = ['0','1','2','3','4','5','6','7','8','9'];
    const positions = [
      { x: 400, y: 520 },
      { x: 100, y: 80 },
      { x: 700, y: 80 },
      { x: 400, y: 80 }
    ];
    const dropZone = { x: 400, y: 300, width: 120, height: 160 };

    function preload() {
      // Kartenbilder laden
      for (let color of colors) {
        for (let number of numbers) {
          let key = `${color}_${number}`;
          this.load.image(key, `assets/cards/${key}.png`);
        }
      }
    }

    function create() {
      this.children.removeAll();

      if (deck.length === 0) {
        deck = createDeck();
        Phaser.Utils.Array.Shuffle(deck);
        for (let i = 0; i < 4; i++) {
          players[i] = deck.splice(0, 7);
        }
        discardPile.push(deck.pop());
      }

      drawDiscardPile(this);

      for (let i = 1; i < 4; i++) {
        this.add.rectangle(positions[i].x, positions[i].y, 180, 100, 0x333333)
          .setStrokeStyle(2, currentPlayer === i ? 0xffff00 : 0xffffff)
          .setName(`botFrame${i}`);
        this.add.text(positions[i].x - 70, positions[i].y - 40, 'Bot ' + i, { fontSize: '16px', fill: '#fff' });
        this.add.text(positions[i].x - 70, positions[i].y, 'Karten: ' + players[i].length, { fontSize: '14px', fill: '#fff' })
          .setName(`botCount${i}`);
      }

      highlightActivePlayer(this);
      drawPlayerHand(this);

      if (currentPlayer === 0) {
        activatePlayerInput(this);
        createDrawButton(this);
      }

      const dz = this.add.rectangle(dropZone.x, dropZone.y, dropZone.width, dropZone.height, 0xffffff, 0.1);
      dz.setStrokeStyle(2, 0xffffff);

      this.input.on('wheel', (pointer, gameObjects, dx, dy) => {
        scrollOffset -= dy * 0.1;
        scrollOffset = Phaser.Math.Clamp(scrollOffset, -200, 200);
        drawPlayerHand(this);
      });

      if (currentPlayer !== 0) {
        this.time.delayedCall(2000, () => botTurn(this), [], this);
      }
    }

    function update() {}

    function createDeck() {
      let newDeck = [];
      for (let color of colors) {
        for (let number of numbers) {
          newDeck.push({ color: color, value: number });
        }
      }
      return newDeck;
    }

    function drawDiscardPile(scene) {
      scene.children.list.filter(child => child.discardPile).forEach(child => child.destroy());
      let topCard = discardPile[discardPile.length - 1];
      let container = createCardContainer(scene, topCard, dropZone.x, dropZone.y);
      container.discardPile = true;
    }

    function drawPlayerHand(scene) {
      cardSprites.forEach(cs => cs.destroy());
      cardSprites = [];

      const hand = players[0];
      const startX = 200 + scrollOffset;
      const gap = 100;

      hand.forEach((card, index) => {
        let x = startX + index * gap;
        let y = positions[0].y;
        let cardContainer = createCardContainer(scene, card, x, y);
        cardContainer.originalX = x;
        cardContainer.originalY = y;
        cardContainer.setSize(80, 120);
        cardContainer.setInteractive(new Phaser.Geom.Rectangle(0, 0, 80, 120), Phaser.Geom.Rectangle.Contains);
        scene.input.setDraggable(cardContainer);
        cardContainer.card = card;
        cardSprites.push(cardContainer);
      });
    }

    function createCardContainer(scene, card, x, y) {
      let key = `${card.color}_${card.value}`;
      let sprite = scene.add.image(0, 0, key).setDisplaySize(80, 120);
      let container = scene.add.container(x, y, [sprite]);
      return container;
    }

    function isPlayable(card) {
      let topCard = discardPile[discardPile.length - 1];
      return (card.color === topCard.color || card.value === topCard.value);
    }

    function activatePlayerInput(scene) {
      cardSprites.forEach(cardContainer => {
        cardContainer.setInteractive();
        scene.input.setDraggable(cardContainer);
      });

      scene.input.on('dragstart', (pointer, gameObject) => {
        gameObject.setScale(1.1);
      });
      scene.input.on('drag', (pointer, gameObject, dragX, dragY) => {
        gameObject.x = dragX;
        gameObject.y = dragY;
      });
      scene.input.on('dragend', (pointer, gameObject) => {
        gameObject.setScale(1);
        if (Phaser.Geom.Rectangle.ContainsPoint(
          new Phaser.Geom.Rectangle(dropZone.x - dropZone.width/2, dropZone.y - dropZone.height/2, dropZone.width, dropZone.height),
          { x: gameObject.x, y: gameObject.y })) {
          if (isPlayable(gameObject.card)) {
            playPlayerCard(gameObject.card);
            gameObject.destroy();
            cardSprites = cardSprites.filter(cs => cs !== gameObject);
            removeDrawButton();
            nextTurn(scene);
            return;
          }
        }
        gameObject.x = gameObject.originalX;
        gameObject.y = gameObject.originalY;
      });
    }

    function createDrawButton(scene) {
      drawButton = scene.add.text(510, 260, 'Karte ziehen', { fontSize: '20px', backgroundColor: '#555', padding: { x: 10, y: 5 } })
        .setInteractive()
        .on('pointerdown', () => {
          if (deck.length > 0) {
            let newCard = deck.pop();
            players[0].push(newCard);
          }
          removeDrawButton();
          nextTurn(scene);
        });
    }

    function removeDrawButton() {
      if (drawButton) {
        drawButton.destroy();
        drawButton = null;
      }
    }

    function playPlayerCard(card) {
      const index = players[0].findIndex(c => c.color === card.color && c.value === card.value);
      if (index !== -1) {
        players[0].splice(index, 1);
        discardPile.push(card);
      }
    }

    function highlightActivePlayer(scene) {
      scene.add.rectangle(positions[0].x, positions[0].y, 200, 140)
        .setStrokeStyle(2, 0xffff00, 0.3)
        .setDepth(-1)
        .setOrigin(0.5);
    }

    function nextTurn(scene) {
      for (let i = 0; i < players.length; i++) {
        if (players[i].length === 0) {
          scene.add.text(300, 280, i === 0 ? 'Du hast gewonnen!' : 'Bot ' + i + ' hat gewonnen!', { fontSize: '24px', fill: '#0f0' });
          scene.add.text(300, 320, 'Neustarten', { fontSize: '20px', backgroundColor: '#444', padding: { x: 10, y: 5 } })
            .setInteractive()
            .on('pointerdown', () => {
              deck = [];
              discardPile = [];
              players = [];
              currentPlayer = 0;
              scene.scene.restart();
            });
          return;
        }
      }

      currentPlayer = (currentPlayer + 1) % 4;

      // Bot-Rahmen aktualisieren
      for (let i = 1; i < 4; i++) {
        const frame = scene.children.getByName(`botFrame${i}`);
        if (frame) frame.setStrokeStyle(2, currentPlayer === i ? 0xffff00 : 0xffffff);
      }

      if (currentPlayer === 0) {
        drawPlayerHand(scene);
        highlightActivePlayer(scene);
        createDrawButton(scene);
      } else {
        scene.time.delayedCall(2000, () => botTurn(scene), [], scene);
      }

      drawDiscardPile(scene);
    }

    function botTurn(scene) {
      let botCards = players[currentPlayer];
      let playableIndex = botCards.findIndex(isPlayable);
      if (playableIndex !== -1) {
        let card = botCards.splice(playableIndex, 1)[0];
        discardPile.push(card);
      } else {
        if (deck.length > 0) {
          botCards.push(deck.pop());
        }
      }
      nextTurn(scene);
    }
  </script>
</body>
</html>
