<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Uno</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    /* Gesamte Seite im dunklen, minimalistischen Stil */
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1c1c1e, #2c2c2e);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #eee;
      overflow: hidden;
    }
    
    /* Größerer und moderner Container für das Spiel */
    #game-container {
      border: none;
      background: #2c2c2e;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      margin: 30px auto;
      position: relative;
      width: 1200px;
      height: 800px;
    }
    
    /* Der kleine rote Punkt oben links */
    .home-link {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 16px;
      height: 16px;
      background: #ff3b30;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
    }
    
    /* Zusätzliche Texte und Buttons im Apple-Stil */
    .button {
      font-size: 20px;
      background-color: #3a3a3c;
      padding: 8px 12px;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      user-select: none;
    }
    .button:hover {
      background-color: #4a4a4c;
    }
  </style>
</head>
<body>
  <!-- Roter Punkt als Home-Button -->
  <a href="index.html" class="home-link"></a>

  <div id="game-container"></div>

  <script>
    const config = {
      type: Phaser.AUTO,
      width: 1200,
      height: 800,
      parent: 'game-container',
      scene: {
        preload: preload,
        create: create,
        update: update
      }
    };

    const game = new Phaser.Game(config);

    let players = [];
    let currentPlayer = 0;
    let deck = [];
    let discardPile = [];
    let cardSprites = [];
    let drawButton;
    let scrollOffset = 0;

    const colors = ['Rot', 'Gelb', 'Grün', 'Blau'];
    const numbers = ['0','1','2','3','4','5','6','7','8','9'];
    // Angepasste Positionen für ein größeres Spielfeld
    const positions = [
      { x: 600, y: 720 }, // Spieler unten
      { x: 150, y: 100 }, // Bot 1 links oben
      { x: 1050, y: 100 }, // Bot 2 rechts oben
      { x: 600, y: 100 }  // Bot 3 Mitte oben
    ];
    // DropZone in der Mitte des Spielfelds
    const dropZone = { x: 600, y: 400, width: 140, height: 180 };

    // Eigene Bot-Namen
    const botNames = ["Alice", "Bob", "Charlie"];

    function preload() {
      // Kartenbilder laden
      for (let color of colors) {
        for (let number of numbers) {
          let key = `${color}_${number}`;
          this.load.image(key, `assets/cards/${key}.png`);
        }
      }
      // Profilbilder für die Bots laden (sicherstellen, dass diese Bilder in assets/ vorhanden sind)
      this.load.image('botProfile1', 'assets/bot1.png');
      this.load.image('botProfile2', 'assets/bot2.png');
      this.load.image('botProfile3', 'assets/bot3.png');
    }

    function create() {
      this.children.removeAll();

      if (deck.length === 0) {
        deck = createDeck();
        Phaser.Utils.Array.Shuffle(deck);
        for (let i = 0; i < 4; i++) {
          players[i] = deck.splice(0, 7);
        }
        discardPile.push(deck.pop());
      }

      drawDiscardPile(this);

      // Bot-Rahmen inkl. Profilbild, Name und Kartenanzahl innerhalb des Rahmens
      for (let i = 1; i < 4; i++) {
        // Rahmen zeichnen
        this.add.rectangle(positions[i].x, positions[i].y, 220, 120, 0x444444)
          .setStrokeStyle(3, currentPlayer === i ? 0xffcc00 : 0xaaaaaa)
          .setName(`botFrame${i}`);
        // Profilbild innerhalb des Rahmens (oberer Bereich)
        this.add.image(positions[i].x, positions[i].y - 20, `botProfile${i}`)
          .setDisplaySize(40, 40);
        // Bot-Name unterhalb der Mitte (mittig ausgerichtet)
        this.add.text(positions[i].x, positions[i].y + 10, botNames[i - 1], { fontSize: '18px', fill: '#eee' })
          .setOrigin(0.5);
        // Kartenanzahl unterhalb des Namens
        this.add.text(positions[i].x, positions[i].y + 30, 'Karten: ' + players[i].length, { fontSize: '16px', fill: '#eee' })
          .setOrigin(0.5)
          .setName(`botCount${i}`);
      }

      highlightActivePlayer(this);
      drawPlayerHand(this);

      // Nur Spieler am Zug erhält Eingabesteuerung und den Draw-Button
      if (currentPlayer === 0) {
        activatePlayerInput(this);
        createDrawButton(this);
      } else {
        deactivatePlayerInput(this);
      }

      // DropZone als transparenter Rahmen in der Mitte
      const dz = this.add.rectangle(dropZone.x, dropZone.y, dropZone.width, dropZone.height, 0xffffff, 0.1);
      dz.setStrokeStyle(3, 0xffffff);

      this.input.on('wheel', (pointer, gameObjects, dx, dy) => {
        scrollOffset -= dy * 0.1;
        scrollOffset = Phaser.Math.Clamp(scrollOffset, -200, 200);
        drawPlayerHand(this);
      });

      if (currentPlayer !== 0) {
        this.time.delayedCall(2000, () => botTurn(this), [], this);
      }
    }

    function update() {}

    function createDeck() {
      let newDeck = [];
      for (let color of colors) {
        for (let number of numbers) {
          newDeck.push({ color: color, value: number });
        }
      }
      return newDeck;
    }

    function drawDiscardPile(scene) {
      scene.children.list.filter(child => child.discardPile).forEach(child => child.destroy());
      let topCard = discardPile[discardPile.length - 1];
      let container = createCardContainer(scene, topCard, dropZone.x, dropZone.y);
      container.discardPile = true;
    }

    function drawPlayerHand(scene) {
      cardSprites.forEach(cs => cs.destroy());
      cardSprites = [];

      const hand = players[0];
      const startX = 350 + scrollOffset;
      const gap = 100;

      hand.forEach((card, index) => {
        let x = startX + index * gap;
        let y = positions[0].y;
        let cardContainer = createCardContainer(scene, card, x, y);
        cardContainer.originalX = x;
        cardContainer.originalY = y;
        cardContainer.setSize(80, 120);
        cardContainer.setInteractive(new Phaser.Geom.Rectangle(0, 0, 80, 120), Phaser.Geom.Rectangle.Contains);
        scene.input.setDraggable(cardContainer);
        cardContainer.card = card;
        cardSprites.push(cardContainer);
      });
    }

    function createCardContainer(scene, card, x, y) {
      let key = `${card.color}_${card.value}`;
      let sprite = scene.add.image(0, 0, key).setDisplaySize(80, 120);
      let container = scene.add.container(x, y, [sprite]);
      return container;
    }

    function isPlayable(card) {
      let topCard = discardPile[discardPile.length - 1];
      return (card.color === topCard.color || card.value === topCard.value);
    }

    function activatePlayerInput(scene) {
      cardSprites.forEach(cardContainer => {
        cardContainer.setInteractive();
        scene.input.setDraggable(cardContainer);
      });

      scene.input.on('dragstart', (pointer, gameObject) => {
        if (currentPlayer !== 0) return;
        gameObject.setScale(1.1);
      });
      scene.input.on('drag', (pointer, gameObject, dragX, dragY) => {
        if (currentPlayer !== 0) return;
        gameObject.x = dragX;
        gameObject.y = dragY;
      });
      scene.input.on('dragend', (pointer, gameObject) => {
        if (currentPlayer !== 0) return;
        gameObject.setScale(1);
        if (Phaser.Geom.Rectangle.ContainsPoint(
          new Phaser.Geom.Rectangle(dropZone.x - dropZone.width/2, dropZone.y - dropZone.height/2, dropZone.width, dropZone.height),
          { x: gameObject.x, y: gameObject.y }
        )) {
          if (isPlayable(gameObject.card)) {
            playPlayerCard(gameObject.card);
            gameObject.destroy();
            cardSprites = cardSprites.filter(cs => cs !== gameObject);
            removeDrawButton();
            nextTurn(scene);
            return;
          }
        }
        gameObject.x = gameObject.originalX;
        gameObject.y = gameObject.originalY;
      });
    }

    function deactivatePlayerInput(scene) {
      cardSprites.forEach(cardContainer => {
        cardContainer.disableInteractive();
      });
    }

    function createDrawButton(scene) {
      // Button links außerhalb der Dropzone positioniert
      drawButton = scene.add.text(100, 600, 'Karte ziehen', { fontSize: '24px', backgroundColor: '#3a3a3c', padding: { x: 12, y: 8 } })
        .setInteractive()
        .on('pointerdown', () => {
          if (deck.length > 0) {
            let newCard = deck.pop();
            players[0].push(newCard);
          }
          removeDrawButton();
          nextTurn(scene);
        });
    }

    function removeDrawButton() {
      if (drawButton) {
        drawButton.destroy();
        drawButton = null;
      }
    }

    function playPlayerCard(card) {
      const index = players[0].findIndex(c => c.color === card.color && c.value === card.value);
      if (index !== -1) {
        players[0].splice(index, 1);
        discardPile.push(card);
      }
    }

    // Spieler-Rahmen: Nur ein transparenter Rahmen mit halbtransparentem Strich
    function highlightActivePlayer(scene) {
	// Rahmen nur für Bots (oder andere Spieler), nicht für den menschlichen Spieler
	if (currentPlayer !== 0) {
		scene.add.rectangle(positions[0].x, positions[0].y, 260, 160)
		.setStrokeStyle(3, 0xffcc00, 0.3)
		.setDepth(-1)
		.setOrigin(0.5);
  }
}

    function nextTurn(scene) {
      // Gewinnprüfung
      for (let i = 0; i < players.length; i++) {
        if (players[i].length === 0) {
          scene.add.text(500, 380, i === 0 ? 'Du hast gewonnen!' : botNames[i - 1] + ' hat gewonnen!', { fontSize: '32px', fill: '#0f0' });
          scene.add.text(500, 430, 'Neustarten', { fontSize: '28px', backgroundColor: '#3a3a3c', padding: { x: 12, y: 8 } })
            .setInteractive()
            .on('pointerdown', () => {
              deck = [];
              discardPile = [];
              players = [];
              currentPlayer = 0;
              scene.scene.restart();
            });
          return;
        }
      }

      // Nächster Zug
      currentPlayer = (currentPlayer + 1) % 4;

      // Aktualisierung der Bot-Rahmen und Kartenanzahl
      for (let i = 1; i < 4; i++) {
        const frame = scene.children.getByName(`botFrame${i}`);
        if (frame) frame.setStrokeStyle(3, currentPlayer === i ? 0xffcc00 : 0xaaaaaa);
        
        const countText = scene.children.getByName(`botCount${i}`);
        if (countText) {
          countText.setText('Karten: ' + players[i].length);
        }
      }

      // Spielerzug: Eingaben aktivieren und Button anzeigen
      if (currentPlayer === 0) {
        drawPlayerHand(scene);
        highlightActivePlayer(scene);
        activatePlayerInput(scene);
        createDrawButton(scene);
      } else {
        deactivatePlayerInput(scene);
        scene.time.delayedCall(2000, () => botTurn(scene), [], scene);
      }

      drawDiscardPile(scene);
    }

    function botTurn(scene) {
      let botCards = players[currentPlayer];
      let playableIndex = botCards.findIndex(isPlayable);
      if (playableIndex !== -1) {
        let card = botCards.splice(playableIndex, 1)[0];
        discardPile.push(card);
      } else {
        if (deck.length > 0) {
          botCards.push(deck.pop());
        }
      }
      nextTurn(scene);
    }
  </script>
</body>
</html>
